设计模式分为23种：
1) 创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式
2) 结构性模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式
3) 行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、
             状态模式、策略模式、责任链模式（职责链模式）

1、单例模式
    思想：
        采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。
    实现方式：
        [1] 饿汉式（静态常量）
        [2] 饿汉式（静态代码块）
        [3] 懒汉式（线程不安全）
        [4] 懒汉式（线程安全，同步方法）
        [5] 懒汉式（线程安全，同步代码块）
        [6] 双重检查
        [7] 静态内部类
        [8] 枚举
    优缺点：
        （1）写法简单，避免了线程同步问题，但是可能造成内存浪费。
    具体实现：
        （1）饿汉式（静态常量）
            <1> 将构造器私有化（防止从外部new一个）
            <2> 在类的内部创建对象  -> 直接new一个
            <3> 向外暴露一个静态的公共方法。getInstance
            <4> 代码实现
        （2）饿汉式（静态代码块）
            与静态常量的实现方式类似，只不过将new一个对象的方法放在了静态代码块之中
        （3）懒汉式（线程不安全）
            现实中不适用
        （4）懒汉式（同步方法）
            效率低下
        （5）懒汉式（同步代码块）
            无法实现同步
        （6）双重检验
            可以有效实现
            如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的，同时还会禁止指令重排序
        （7）枚举
            可以防止通过反射来破坏单例模式
    JDK源码：
        Runtime()


2、工厂模式
    思想：
        使得代码遵循OCP原则，便于后期维护
    实现方式：
        [1] 简单工厂模式  -> 由一个工厂对象决定创建出哪一种产品类的实例
        [2] 工厂方法模式  -> 定义了一个创建对象的抽象方法，由子类决定要实例化的类。即将对象的实例化推迟到子类之中。
        [3] 抽象工厂模式  -> 定义了一个interface用于创建相关相关或有依赖关系的对象簇
                        -> 将工厂抽象成两层，AbsFactory(抽象工厂)和具体实现的工厂子类

    具体实现：
        （1）定义一个创建对象的类，由这个类来封装实例化对象的行为。
        （2）在原有架构之上增加一层
        （3）将原有的方法抽象在一个接口之中，使得具体的工厂子类实现该接口
    JDK源码：Calendar中的getInstance

3、原型模式
    思想：
        用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。
    实现方式：
        [1] 调用Object类之中的clone()方法来实现

    具体实现：
        （1）对Object类中的clone方法进行重写