设计模式分为23种：
1) 创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式
2) 结构性模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式
3) 行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、
             状态模式、策略模式、责任链模式（职责链模式）

1、单例模式
    思想：
        采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。
    实现方式：
        [1] 饿汉式（静态常量）
        [2] 饿汉式（静态代码块）
        [3] 懒汉式（线程不安全）
        [4] 懒汉式（线程安全，同步方法）
        [5] 懒汉式（线程安全，同步代码块）
        [6] 双重检查
        [7] 静态内部类
        [8] 枚举
    优缺点：
        （1）写法简单，避免了线程同步问题，但是可能造成内存浪费。
    具体实现：
        （1）饿汉式（静态常量）
            <1> 将构造器私有化（防止从外部new一个）
            <2> 在类的内部创建对象  -> 直接new一个
            <3> 向外暴露一个静态的公共方法。getInstance
            <4> 代码实现
        （2）饿汉式（静态代码块）
            与静态常量的实现方式类似，只不过将new一个对象的方法放在了静态代码块之中
        （3）懒汉式（线程不安全）
            现实中不适用
        （4）懒汉式（同步方法）
            效率低下
        （5）懒汉式（同步代码块）
            无法实现同步
        （6）双重检验
            可以有效实现
            如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的，同时还会禁止指令重排序
        （7）枚举
            可以防止通过反射来破坏单例模式
    JDK源码：
        Runtime()


2、工厂模式
    思想：
        使得代码遵循OCP原则，便于后期维护
    实现方式：
        [1] 简单工厂模式  -> 由一个工厂对象决定创建出哪一种产品类的实例
        [2] 工厂方法模式  -> 定义了一个创建对象的抽象方法，由子类决定要实例化的类。即将对象的实例化推迟到子类之中。
        [3] 抽象工厂模式  -> 定义了一个interface用于创建相关相关或有依赖关系的对象簇
                        -> 将工厂抽象成两层，AbsFactory(抽象工厂)和具体实现的工厂子类

    具体实现：
        （1）定义一个创建对象的类，由这个类来封装实例化对象的行为。
        （2）在原有架构之上增加一层
        （3）将原有的方法抽象在一个接口之中，使得具体的工厂子类实现该接口
    JDK源码：Calendar中的getInstance

3、原型模式
    思想：
        用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。
    实现方式：
        [1] 调用Object类之中的clone()方法来实现
        [2] 使用序列化-反序列化的方式进行实现

    具体实现：
        （1）对Object类中的clone方法进行重写
        （2）将对象通过对象流的方式写入内存之中，接下来通过对象流读入进去


4、建造者模式
    思想：
        将复杂对象的建造过程抽象出来，使得这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。
    人话：
        将对象的创建过程进行疯狂解耦，使得对象类、创建对象的类、指挥创建对象的类、客户端分离，在创建对象的类之中内置一个对象，
        并且创建一个抽象的创建对象的类（抽象类或者接口），使得具体实现的类去继承该类，并对创建对象所需要的普遍方法进行重写。
        接下来在指挥创建对象的类之中设置一个属性，该属性为创建对象的类，由指挥者（设计师）去指挥建造者（工人）去创建一个对象。
    具体实现：
        创建的对象抽象出一个抽象类或者接口(House)。
        接下来通过具体的对应的实例去继承或实现该接口或类(使用CommonHouse去继承HouseBuilder)。
        通过Director去指挥对象创建。

5、适配器模式
    思想：
        将某个类的接口转换成客户端期望的另一个接口表示。
        主要目的是兼容性，让原本因接口不能匹配不能一起工作的两个类可以协同工作。
    分类：
        类适配器模式、对象适配器模式、接口适配器模式
    具体实现:
        （1）继承被适配类
        （2）创建一个被适配类的对象，以聚合的形式进行实现。
        （3）当不需要全部实现接口提供的方法的时候，可以先设计一个抽象类实现接口，并为该接口中的每一个方法都提供一个默认实现方法
            （空方法），那么该抽象类的子类可以有选择地覆盖父类的某些方法来实现需求


6、桥接模式
    思想：
        将显示与抽象放在两个不同的类层次之中，使得两个层次可以独立改变
    具体实现：
        基于类的最小设计原则，通过使用封装、聚合及继承等行为让不用的类承担不同的职责。
        主要特点是把抽象与行为实现分离开来。
    人话：
        实际上是将手机的具体品牌和类型进行分离。
        不同的手机品牌实现Bread接口，而在手机这个抽象类中聚合Bread对象
        通过该对象可以调用对应品牌中的方法（重写的Interface中的方法）
        接下来对应于不同的手机类型均可以继承Phone -> 也可以通过bread调用对应的方法



7、装饰者模式
    思想：
        动态地将新功能附加到对象上。
        在对象功能扩展方面，它比继承更有弹性，装饰着模式也体现了开闭原则（OCP）

8、组合模式
    思想：
        又称为部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次关系
    人话：
        将共同的部分提取出来作为抽象类或者接口，中间节点对父类中的方法进行重写，而叶子节点无需重写。
        在中间节点之中，以父类的方式存储为一个对象链表，用于指向其存储的下一层节点。
    JDK：
        HashMap之中使用了该模式  在AbstractMap中对Map接口进行实现，而HashMap继承了AbstractMap
        在HashMap之中有一个静态内部类为Node，为叶子节点





